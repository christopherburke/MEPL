import numpy as np
def meeple_outline(phis, sz):
    """ Returns a parametric x, y curve of a meeple outline.
        The meeple is centered on (0,0) and has rough size given by sz.
        The meeple outline was generated by taking a meeple svg outline graphic
        Converting the svg paths to sample polygon points along the meeple curve.
        Taking a FFT of the x and y polygon points separately and keeping the
        30 terms hardcoded in xAmps and yAmps below.
        Inspired by this post
        http://blog.wolframalpha.com/2013/05/17/making-formulas-for-everything-from-pi-to-the-pink-panther-to-sir-isaac-newton/
        Meeple svg from 
        http://game-icons.net/delapouite/originals/meeple.html
        Svg read and parsed with BeautifulSoup
        svg path parsed and sampled into polygons with svg.path
        https://pypi.python.org/pypi/svg.path
        
        AUTHOR: Christopher J Burke
        INPUT:
            phis - np.array of phases from [0, 2pi]
            sz - rough scale for meeple outline
        OUTPUT:
            tmpx - x points corresponding to phis as numpy array
            tmpy - y points correspoinding to phis as numpy array
"""
    xAmps = np.array([3920.18901235 +0.00000000e+00j, -3320.43930133 +4.70014934e+04j,
       -2029.60733908 +1.42763683e+04j,    94.71192678 -4.35344790e+02j,
       -1769.69054407 +6.11490638e+03j, -1004.04347187 +2.71922326e+03j,
        2686.72233332 -5.96728097e+03j,  1878.72377852 -3.48291301e+03j,
        -513.02972392 +8.06191293e+02j,   746.18342753 -1.01674555e+03j,
        -752.59025615 +8.90044951e+02j,   253.58361725 -2.60333050e+02j,
        1414.63803234 -1.25510187e+03j,  -602.63972571 +4.65734683e+02j,
       -1770.59909524 +1.16789086e+03j,  -222.50561750 +1.23191621e+02j,
         462.31029214 -2.16410691e+02j,  -296.34271216 +1.14845203e+02j,
         410.84682184 -1.29190504e+02j,  -285.50905020 +6.92248072e+01j,
        -604.65379580 +9.71211318e+01j,   992.70780286 -9.07447690e+01j,
         870.93297878 -1.49124294e+01j,    42.62556646 +1.87978961e+00j,
         498.63479491 +5.95760792e+01j,   652.08489588 +1.28474077e+02j,
         117.51219329 +3.17683918e+01j,   560.94832280 +1.92833022e+02j,
         467.20132352 +2.00714269e+02j,  -272.40866118 -1.39462977e+02j]);
    yAmps= np.array([ -3.65736437e+04 +0.00000000e+00j,
         3.55013533e+04 +2.50914957e+03j,         2.19595142e+04 +3.11776472e+03j,
         -3.13928526e+03 -6.74847706e+02j,         3.08650222e+03 +8.95030624e+02j,
         3.81790310e+03 +1.40535917e+03j,         5.54190080e+03 +2.49558679e+03j,
         3.53607267e+02 +1.89835184e+02j,        -9.01494182e+02 -5.70041486e+02j,
        -2.36224580e+02 -1.73467499e+02j,         9.33589503e+02 +7.93891563e+02j,
         1.21248302e+03 +1.18920658e+03j,        -6.65286471e+02 -7.50650357e+02j,
        -7.41145924e+01 -9.70731943e+01j,        -2.45856442e+02 -3.73288297e+02j,
         3.23417613e+02 +5.74856428e+02j,         5.74054431e+01 +1.21648232e+02j,
        -3.19240426e+02 -8.19013453e+02j,        -4.36333228e+01 -1.41070084e+02j,
        -9.97095870e+00 -4.17224394e+01j,         5.13170786e+01 +3.19063100e+02j,
        -4.69872207e+00 -5.57473956e+01j,        -1.58275429e+00 -8.77000772e+01j,
        -2.69448857e-01 -2.14215900e+00j,         7.10138194e+00 -5.70668492e+01j,
         1.80086306e+01 -9.13924491e+01j,         4.84661919e+01 -1.80772552e+02j,
        -3.13440168e+01 +9.03953478e+01j,         6.93010670e+01 -1.61957327e+02j,
         6.91871164e+01 -1.34652184e+02j])
    nSamples = 490
    nSFloat = np.double(nSamples)
    
    linphase = phis / 2.0 / np.pi * (nSFloat)
    nk = len(xAmps)
    try:    
        nm = len(phis)
    except TypeError:
        nm = 1
        linphase = np.array([phis]) / 2.0 / np.pi * (nSFloat) 
    kvals = np.arange(nk)
    xAmp2d = np.reshape(np.repeat(xAmps, nm), (nk, nm))
    yAmp2d = np.reshape(np.repeat(yAmps, nm), (nk, nm))
    linphase2d = np.reshape(np.repeat(linphase, nk), (nm, nk)).T
    kval2d = np.reshape(np.repeat(kvals, nm), (nk, nm))
    arg2d = 2.0 * np.pi * 1j * linphase2d * kval2d / nSFloat
    tmpx = np.sum(xAmp2d * np.exp(arg2d), axis = 0) / nSFloat
    tmpy = np.sum(yAmp2d * np.exp(arg2d), axis = 0) / nSFloat
    tmpx = (np.real(tmpx) - 7.0) * sz / 400.0
    tmpy = (np.real(tmpy) + 32.0) * sz / 400.0
    return tmpx, tmpy
